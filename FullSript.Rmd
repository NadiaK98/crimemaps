---
title: "Crime mapping in R"
author: "Nads"
date: "25/10/2021"
output: html_document
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# for data reading/manipulation 
library(dplyr)
library(tidyr)
library(readr)
library(tibble)
library(janitor)
# for spatial data and gis
library(sf)
library(ggplot2)
library(ggspatial)
library(spdep)
library(leaflet) 
library(RColorBrewer)
library(tmap)

```


# Prerequisite 

This workshop is suitable for those beginner to intermediate in R. It requires you know how to set your working directory, how to read data into R.

Using open source police recorded crime statistics from 2019 this workshop will demonstrate how to map crime data in R using sf and ggplot. More specifically looking at the area of Surrey we will 

  1) briefly explore the crime data and introduce key topics in spatial data
  2) demonstrate how to use shapefiles to map data 
  3) calculate and map crime rate 


The datasets needed in this workshop include crime data, population statistics and shapefiles. Information on how to download these will be available in R file names 'downloading the data' but feel free to obtain these via git *add link*. Ensure these are loaded into your environment before starting the workshop




# Topic 1 - Intro to spatial data 

## Downloading the crime data 

 *https://data.police.uk/*. 

Select January 2019 to December 2019, from the City of London Police and click 'Include Crime Data'. Download and unzip the data into your working directory

Read in just the January 2019 month of data


```{r crime data}
#unzip(file.choose())
crime01_19 <- read_csv("Data/2020-08/2020-08-surrey-street.csv") %>% 
  janitor::clean_names() 

#explore variables
glimpse(crime01_19)

```

Points, lines and polygon 

- Our coordinate variables (the latitude and longitude) are known as point data 
- The 'location' variable represents the line. This is normally define by a street or junction 
- The 'lsoa name' represent our polygon (borough, wards, districts etc). LSOA refers to the Lower Layer Super Output Areas which are a unit measure in census geography 




## Simple Features and Projection methods

Simple Features is a common R language, known as sf packages, that allow you to handle and manipulate the UoA (points, lines and polyons). Simple Features allows you store spatial objects

Features refers to the property that linestring and polygons are built from points by straight line segments

- simple features or spatial polygons (sf vs sp) 

crs: 

CRS are  is a coordinate-based local, regional or global system used to locate geographical entities. A spatial reference system defines a specific map projection, as well as transformations between different spatial reference systems. [â€¦] spatial reference systems can be referred to using a SRID integer, including EPSG codes

In short "Projection methods allow us to move move from the 3D to the 2D, CRS allow us to identify specific locations within these 

There are thousands of CRS, the most common being BNG and the WGS 84 

Each crs has an ESPG identifier
i.e. the BNG = 27700
i.e. the WGS 84 is 4326 


First step is to transform you ordinary data into an sf object using 'st_as_sf' 


```{r simple features }
st_crs(crime01_19)   # to check the crs

sf <- st_as_sf(crime01_19,                                
                      coords = c("longitude", "latitude"),
                      crs = 4326, 
                      na.fail = FALSE)

```




Other functions 
- agr (atribute-geometry-relationship) = character vector. 
- Specifies for each non-geometry attribute column how it relates to the geometry, and can have one of following values: "constant", "aggregate", "identity". "constant" is used for attributes that are constant throughout the geometry (e.g. land use), "aggregate" where the attribute is an aggregate value over the geometry (e.g. population density or population count), "identity" when the attributes uniquely identifies the geometry of particular "thing", such as a building ID or a city name. The default value, NA_agr_, implies we don't know.






## Mapping point data


```{r}
#### Briefly explore the trend
ggplot(sf, aes(x = crime_type)) + 
  geom_bar()


#### Plot the point data
ggplot() + 
  geom_sf(data = sf)


#### Reference map 
ggplot() + 
  annotation_map_tile() +
  geom_sf(data = sf)


#### Sub-setting for just ASB 
asb <- subset(sf, crime_type == "Anti-social behaviour") %>% 
  select(-c(1, 9, 10))

ggplot() +
  annotation_map_tile() +
  geom_sf(data = asb)
```


### Activity 1

```{r}
#### Activity 1 - How does this compare to 'drugs'?
#Subset the data for the those crime types recorded as 'drugs', create this into a new object like we did for ASB and name it 'drugs' 
#Using ggplot plot the point data over a base map (reference map)


#Solution 

drugs <- subset(sf, crime_type == "Drugs") %>%  
  select(-c(1, 9, 10))

ggplot() +
  annotation_map_tile() +
  geom_sf(data = drugs) 

```







\newpage 


# Topic 2 - Shapefiles 

What are Shapefiles? 

They represent a geospatial vector that is used for GIS software. Shapefiles store both geogrpahic location and its associated attribute infomraiton 

The shapefile format stores the data as primitive geometric shapes like points, lines, and polygons. These shapes, together with data attributes that are linked to each shape, create the representation of the geographic data.

They contain four mandatory file extensions (.shx, .shp, .dbf and the .prj). 
- The .shp contains the geometry data (a 2D axis ordering of coordinate data)
- The .shx contains the positional index of the feature geometry 
- The .dbf contins the attributes for each shape
- The .prj contains the cs and projection information


- Mention crime data and how research in criminology tend to use the LSOA as the main census geography 




Read in the Shapefile for 'Surrey Heath' 

```{r read and plot the boundary for surrey heath}
 
shp_file <- st_read("Data/Shapefile/england_lsoa_2011.shp")


## Plot the Shapefile 
ggplot() + 
  geom_sf(data = shp_file)

```



The original crime01_19 data set contains the individual count of reported crime types across LSOAS, therefore the LSOAs are repeated multiple times. This is because you would expect to see multiple crime counts in one LSOA

In order to highlight how many crimes have occurred in each LSOA, you need to count the crimes per LSOA and we can use this code to do so 


```{r crimes per lsoa}
crimes_grouped_by_lsoa <- crime01_19 %>%
  group_by(lsoa_code) %>%
  summarise(count=n())
```


In our new object you will see two variables, the LSOA and the count of crime in each one.  

We can now join the shapefile (the geospatial vector) and the crimes_grouped_by_losa (the aggregated data)

To join the crimes per lsoa to the shapefile we can use the left_join function that returns all the rows of the table on the left side of the join and matching rows for the table on the right side of join.



```{r merge the data}

surrey_lsoa <- left_join(shp_file, crimes_grouped_by_lsoa, by = c("code" = "lsoa_code"))


#map the data
ggplot() + 
  annotation_map_tile() + 
  geom_sf(data = surrey_lsoa, aes(fill = count), alpha = 0.5) + 
  scale_fill_gradient2(name ="Number of crimes")

```






## Plotting via the 'tmap' package


```{r}
library(tmap)
tm_shape(surrey_lsoa) + 
  tm_fill("count") + 
  tm_borders(alpha = 0.5)
```


How can we better visualise counts? Count data does not equally represent the population distribution at hand, tmaps allows you to add different 'styles' 

The different styles result in different clustering mechanism, tmaps have available on 'jenks'or 'Standard Deviation' 


In this example I've used 'kmeans'. k-means clustering is a method of vector quantisation, originally from signal processing, that aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster.

```{r}
tm_shape(surrey_lsoa) + 
  tm_fill("count", style = "kmeans") + 
  tm_borders(alpha = 0.3)

tm_shape(surrey_lsoa) + 
  tm_fill("count", style = "jenks") + 
  tm_borders(alpha = 0.3)

tm_shape(surrey_lsoa) + 
  tm_fill("count", style = "sd") + 
  tm_borders(alpha = 0.3)

```










## Topic 3: Plotting Using the Census

Count data is not entirely accurate of population density 


For this you can use census data 

```{r}
pop <- read_csv("Data/Census Population/Data_UNIT_URESPOP.csv") %>% slice(3:57) %>% 
  select(2,3,6,7) %>%
  janitor::clean_names() %>%
  rename(pop_density = f2383, 
         pop_count = f136983) %>% 
  mutate(pop_count = as.numeric(pop_count))
```



Again we join this to our surrey_lsoa file, by matching the LSOAs


```{r}
surrey_lsoa <- left_join(surrey_lsoa, pop, by = c("code"="geo_code"))

```



Now you will see the census data has merged into the shapefile, 

A crime rate is calculated by dividing the number of reported by the total population, and then multiplied by 100,000. 

In this case that would be the count variable, divided by the 'pop' variable, and then times by 1000 (we use 1000 as this is the average population of an LSOA, if you were using larger UoA you can choose to multiply by 100,000. Just remember what affect this will have on your rate and how this then interpreted across your results)

In order to work out the crime rate, we need to create a new variable that takes the count/pop*10000

```{r}
surrey_lsoa <- surrey_lsoa %>% 
  mutate(crime_rate = (count/pop_count)*1000)

```



Now lets explore these trends using ggplot and tmap 

##ggplot

```{r}
ggplot() + 
  annotation_map_tile() + 
  geom_sf(data = surrey_lsoa, aes(fill = crime_rate), alpha = 0.5) + 
  scale_fill_gradient2(name ="Number of crimes")
```


##tmaps 


```{r}
tm_shape(surrey_lsoa) + 
  tm_fill("crime_rate", style = "quantile") + 
  tm_borders(alpha = 0.3)
```










# Extra Topic: Interactive Maps; Leaflet

```{r}

## Subsetting for just ASB 
asb <- subset(crime01_19, crime_type == "Anti-social behaviour")

m <- leaflet(data = asb) %>%
  addProviderTiles("Stamen.Toner") %>% 
  addMarkers(lng=~longitude, lat=~latitude, popup=~as.character(location), label = ~as.character(location))
m

```



















